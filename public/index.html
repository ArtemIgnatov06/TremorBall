<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>TremorBall Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Roboto:wght@400;700&display=swap');

        body { margin: 0; background: #121212; color: white; font-family: 'Roboto', sans-serif; overflow: hidden; }
        
        .screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            z-index: 10; 
            background: linear-gradient(135deg, #1e3c72, #2a5298); 
        }
        .hidden { display: none !important; }

        h1 { font-family: 'Black Ops One', cursive; font-size: 80px; margin-bottom: 20px; text-shadow: 0 10px 20px rgba(0,0,0,0.5); }
        .btn { padding: 15px 40px; margin: 10px; font-size: 24px; font-weight: bold; background: white; color: #333; border: none; border-radius: 50px; cursor: pointer; font-family: 'Black Ops One', cursive; text-transform: uppercase; transition: 0.2s; }
        .btn:hover { transform: scale(1.1); box-shadow: 0 0 20px white; }
        .btn-secondary { background: #333; color: white; }
        .link-box { background: rgba(0,0,0,0.6); padding: 15px; border-radius: 10px; font-family: monospace; font-size: 18px; color: #4cd137; border: 2px solid #4cd137; margin-top: 20px; user-select: all; cursor: pointer; }
        .skin-selector { display: flex; gap: 10px; margin-bottom: 30px; }
        .skin-option { width: 50px; height: 50px; border-radius: 50%; border: 3px solid white; cursor: pointer; transition: transform 0.2s; }
        .skin-option.selected { box-shadow: 0 0 15px #fff; border-color: yellow; transform: scale(1.3); }

        #game-container { position: relative; width: 100vw; height: 100vh; display: none; justify-content: center; align-items: center; }
        canvas { border: 4px solid #444; box-shadow: 0 0 50px rgba(0,0,0,0.8); background: radial-gradient(circle, #333 0%, #111 100%); border-radius: 8px; }
        #hud { position: absolute; top: 20px; width: 800px; display: flex; justify-content: space-between; font-family: 'Black Ops One', cursive; pointer-events: none; z-index: 5; }
        .score-box { font-size: 60px; text-shadow: 4px 4px 0 #000; }
        
        #win-message { position: absolute; top: 40%; width: 100%; text-align: center; font-size: 100px; font-family: 'Black Ops One'; color: gold; text-shadow: 0 0 20px #000; display: none; z-index: 20; }
    </style>
</head>
<body>

    <div id="menu-screen" class="screen">
        <h1>TREMOR BALL</h1>
        <p>ВЫБЕРИ ЦВЕТ:</p>
        <div class="skin-selector">
            <div class="skin-option selected" style="background: #3498db" onclick="selectSkin('#3498db', this)"></div>
            <div class="skin-option" style="background: #e74c3c" onclick="selectSkin('#e74c3c', this)"></div>
            <div class="skin-option" style="background: #2ecc71" onclick="selectSkin('#2ecc71', this)"></div>
            <div class="skin-option" style="background: #f1c40f" onclick="selectSkin('#f1c40f', this)"></div>
        </div>
        <button class="btn" onclick="findGame('random')">СЛУЧАЙНЫЙ ИГРОК</button>
        <button class="btn btn-secondary" onclick="findGame('private')">ИГРАТЬ С ДРУГОМ</button>
    </div>

    <div id="wait-screen" class="screen hidden">
        <h1>ОЖИДАНИЕ...</h1>
        <div id="invite-section" class="hidden" style="text-align: center;">
            <p>Отправь эту ссылку другу:</p>
            <div id="invite-link" class="link-box" onclick="copyLink()">Генерация...</div>
        </div>
        <button class="btn btn-secondary" onclick="location.reload()" style="margin-top: 30px;">НАЗАД</button>
    </div>

    <div id="game-container">
        <div id="hud">
            <div style="color: #3498db" class="score-box" id="scoreLeft">0</div>
            <div style="color: #e74c3c" class="score-box" id="scoreRight">0</div>
        </div>
        <div id="win-message">ПОБЕДА!</div>
    </div>

<script>
    const socket = io();
    let mySkin = '#3498db';
    let myId = null;
    let mySide = null;
    let playersMap = {}; 
    let ball;
    let engine, render, runner;
    
    // Переменные состояния
    let jumpCount = 0;
    const MAX_JUMPS = 2;
    let lastKeyPress = { key: '', time: 0 };
    let shakeDuration = 0;
    let isFrozen = false; 
    let myTurnToServe = false; 
    let goalProcessed = false; // Блокировка двойного гола

    // --- МЕНЮ ---
    function selectSkin(color, el) { mySkin = color; document.querySelectorAll('.skin-option').forEach(d => d.classList.remove('selected')); el.classList.add('selected'); }
    const urlParams = new URLSearchParams(window.location.search);
    const roomFromUrl = urlParams.get('room');
    if (roomFromUrl) {
        document.getElementById('menu-screen').innerHTML = "<h1>ПОДКЛЮЧЕНИЕ...</h1>";
        setTimeout(() => socket.emit('findMatch', { mode: 'private', roomId: roomFromUrl, skin: mySkin }), 500);
    }
    function findGame(mode) {
        document.getElementById('menu-screen').classList.add('hidden');
        document.getElementById('wait-screen').classList.remove('hidden');
        socket.emit('findMatch', { mode: mode, skin: mySkin });
    }
    socket.on('waiting', (data) => {
        if (data.roomId) {
            document.getElementById('invite-section').classList.remove('hidden');
            document.getElementById('invite-link').innerText = `${window.location.origin}/?room=${data.roomId}`;
        }
    });
    function copyLink() { navigator.clipboard.writeText(document.getElementById('invite-link').innerText).then(() => alert("Ссылка скопирована!")); }

    // --- СЕТЬ ---
    socket.on('gameStart', (data) => {
        document.querySelectorAll('.screen').forEach(el => el.classList.add('hidden'));
        document.getElementById('game-container').style.display = 'flex';
        myId = socket.id; mySide = data.self.side;
        initGame();
        createPlayer(myId, data.self.x, data.self.y, data.self.skin, true);
        data.opponents.forEach(p => createPlayer(p.id, p.x, p.y, p.skin, false));
    });
    socket.on('playerJoined', p => createPlayer(p.id, p.x, p.y, p.skin, false));
    socket.on('playerLeft', id => { if(playersMap[id]) { Matter.Composite.remove(engine.world, playersMap[id]); delete playersMap[id]; } });
    
    socket.on('updatePlayer', (data) => {
        if (playersMap[data.id]) {
            Matter.Body.setPosition(playersMap[data.id], { 
                x: playersMap[data.id].position.x + (data.x - playersMap[data.id].position.x) * 0.5, 
                y: playersMap[data.id].position.y + (data.y - playersMap[data.id].position.y) * 0.5 
            });
        }
    });

    socket.on('updateBall', (data) => {
        if (isFrozen || (playersMap[myId] && calculateDistance(playersMap[myId].position, ball.position) > 150)) {
             Matter.Body.setPosition(ball, { x: data.x, y: data.y });
             Matter.Body.setVelocity(ball, { x: data.vx, y: data.vy });
        }
    });

    socket.on('ballServed', () => {
        isFrozen = false;
        myTurnToServe = false;
        Matter.Body.setStatic(ball, false);
    });

    socket.on('scoreUpdate', s => { 
        document.getElementById('scoreLeft').innerText = s.left; 
        document.getElementById('scoreRight').innerText = s.right; 
    });

    socket.on('gameOver', winner => {
        const msg = document.getElementById('win-message');
        msg.innerText = (winner === mySide ? "ТЫ ВЫИГРАЛ!" : "ТЫ ПРОИГРАЛ");
        msg.style.display = 'block';
        setTimeout(() => msg.style.display = 'none', 3000);
    });

    socket.on('resetRound', data => { 
        goalProcessed = false; // Разрешаем новый гол
        Matter.Body.setPosition(ball, { x: data.x, y: data.y }); 
        Matter.Body.setVelocity(ball, { x: 0, y: 0 }); 
        Matter.Body.setAngularVelocity(ball, 0); 
        
        if (data.serveSide) {
            isFrozen = true;
            Matter.Body.setStatic(ball, true); 
            if (data.serveSide === mySide) {
                myTurnToServe = true; 
            }
        } else {
            isFrozen = false;
            Matter.Body.setStatic(ball, false);
        }
    });

    // --- ФИЗИКА ---
    function initGame() {
        const { Engine, Render, Runner, Bodies, Composite, Body, Events } = Matter;
        engine = Engine.create();
        
        // ГРАВИТАЦИЯ
        engine.world.gravity.y = 1.5; 

        render = Render.create({
            element: document.getElementById('game-container'),
            engine: engine,
            options: { width: 800, height: 600, wireframes: false, background: 'transparent' }
        });

        const CAT_DEFAULT = 0x0001;
        const CAT_PLAYER = 0x0002;
        const CAT_BARRIER = 0x0004;
        const CAT_BALL = 0x0008;

        const ground = Bodies.rectangle(400, 610, 810, 60, { isStatic: true, render: { fillStyle: '#555' }, label: 'ground' });
        const leftWall = Bodies.rectangle(-10, 300, 20, 600, { isStatic: true });
        const rightWall = Bodies.rectangle(810, 300, 20, 600, { isStatic: true });
        
        // СЕТКА ВЫСОКАЯ (320px высотой)
        const netBase = Bodies.rectangle(400, 440, 10, 320, { isStatic: true, render: { fillStyle: '#fff' }, chamfer: { radius: 5 } });
        
        const barrier = Bodies.rectangle(400, 100, 10, 600, { 
            isStatic: true, render: { visible: false }, 
            collisionFilter: { category: CAT_BARRIER, mask: CAT_PLAYER }
        });

        // МЯЧ (ПЛЯЖНЫЙ РЕЖИМ)
        // frictionAir 0.04 - это очень сильно замедляет его в воздухе
        ball = Bodies.circle(400, 150, 35, { 
            restitution: 0.9, 
            friction: 0.001,
            frictionAir: 0.04, // <-- Вот тут плавность полета
            density: 0.04,
            render: { fillStyle: '#f1c40f' },
            label: 'ball',
            collisionFilter: { category: CAT_BALL, mask: CAT_DEFAULT | CAT_PLAYER }
        });

        Composite.add(engine.world, [ground, leftWall, rightWall, netBase, barrier, ball]);

        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (myTurnToServe && isFrozen && ['ArrowLeft','ArrowRight','ArrowUp','KeyA','KeyD','KeyW','Space'].includes(e.code)) {
                socket.emit('serve');
                myTurnToServe = false; isFrozen = false; Body.setStatic(ball, false);
            }
            // Прыжок НИЖЕ (-0.28)
            if ((e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'Space') && playersMap[myId]) {
                if (jumpCount < MAX_JUMPS) {
                    Body.setVelocity(playersMap[myId], { x: playersMap[myId].velocity.x, y: 0 });
                    Body.applyForce(playersMap[myId], playersMap[myId].position, { x: 0, y: -0.28 }); 
                    jumpCount++;
                }
            }
            // Рывок
            const now = Date.now();
            if (lastKeyPress.key === e.code && now - lastKeyPress.time < 300 && playersMap[myId]) {
                const force = 0.35; 
                if (e.code === 'ArrowLeft' || e.code === 'KeyA') Body.applyForce(playersMap[myId], playersMap[myId].position, { x: -force, y: 0 });
                if (e.code === 'ArrowRight' || e.code === 'KeyD') Body.applyForce(playersMap[myId], playersMap[myId].position, { x: force, y: 0 });
                lastKeyPress.key = '';
            } else { lastKeyPress = { key: e.code, time: now }; }
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        // ОБРАБОТКА СТОЛКНОВЕНИЙ
        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;

                // ГОЛ 
                if (!goalProcessed && ((bodyA.label === 'ball' && bodyB.label === 'ground') || (bodyB.label === 'ball' && bodyA.label === 'ground'))) {
                    registerGoal();
                }

                // Сброс прыжка
                if (playersMap[myId] && (bodyA === playersMap[myId] || bodyB === playersMap[myId])) {
                    const other = bodyA === playersMap[myId] ? bodyB : bodyA;
                    if (other.label === 'ground') jumpCount = 0;
                }
            });
        });

        // ИГРОВОЙ ЦИКЛ
        Events.on(engine, 'afterUpdate', () => {
            if (!playersMap[myId]) return;
            const me = playersMap[myId];
            const speed = 7; 

            if (keys['ArrowLeft'] || keys['KeyA']) Body.setVelocity(me, { x: -speed, y: me.velocity.y });
            else if (keys['ArrowRight'] || keys['KeyD']) Body.setVelocity(me, { x: speed, y: me.velocity.y });
            else Body.setVelocity(me, { x: me.velocity.x * 0.85, y: me.velocity.y }); 
            
            Body.setAngle(me, 0);

            socket.emit('move', { x: me.position.x, y: me.position.y, vx: me.velocity.x, vy: me.velocity.y });

            if (!isFrozen && calculateDistance(me.position, ball.position) < 150) {
                socket.emit('syncBall', { x: ball.position.x, y: ball.position.y, vx: ball.velocity.x, vy: ball.velocity.y });
            }

            // СТРАХОВКА ГОЛА (Если физика пропустила удар)
            if (!goalProcessed && ball.position.y > 585) {
                registerGoal();
            }
        });

        function registerGoal() {
            goalProcessed = true; // Блокируем, чтобы не отправить дважды
            if (ball.position.x < 400) {
                if (mySide === 'left') { triggerShake(); socket.emit('goal', 'left'); }
            } else {
                if (mySide === 'right') { triggerShake(); socket.emit('goal', 'right'); }
            }
        }

        Events.on(render, 'beforeRender', () => {
             if (shakeDuration > 0) {
                const dx = (Math.random() - 0.5) * 15;
                const dy = (Math.random() - 0.5) * 15;
                render.canvas.style.transform = `translate(${dx}px, ${dy}px)`;
                shakeDuration--;
            } else { render.canvas.style.transform = 'none'; }
        });

        Render.run(render);
        Runner.run(Runner.create(), engine);
    }

    function createPlayer(id, x, y, color, isMe) {
        if(playersMap[id]) return;
        const p = Matter.Bodies.circle(x, y, 40, { 
            friction: 0, frictionAir: 0.05, restitution: 0, 
            render: { fillStyle: color || '#999', strokeStyle: '#fff', lineWidth: isMe ? 3 : 0 },
            collisionFilter: { category: 0x0002, mask: 0x0001 | 0x0004 | 0x0008 }
        });
        playersMap[id] = p; 
        Matter.Composite.add(engine.world, p);
    }

    function triggerShake() { shakeDuration = 20; }
    function calculateDistance(v1, v2) { return Math.sqrt(Math.pow(v1.x - v2.x, 2) + Math.pow(v1.y - v2.y, 2)); }
</script>
</body>
</html>