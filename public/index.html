<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>TremorBall Online</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Roboto:wght@400;700&display=swap');

        body { margin: 0; background: #121212; color: white; font-family: 'Roboto', sans-serif; overflow: hidden; }
        
        /* ЭКРАНЫ */
        .screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            z-index: 10; 
            background: linear-gradient(135deg, #1e3c72, #2a5298); 
        }
        .hidden { display: none !important; }

        h1 { font-family: 'Black Ops One', cursive; font-size: 80px; margin-bottom: 20px; text-shadow: 0 10px 20px rgba(0,0,0,0.5); }
        
        .btn {
            padding: 15px 40px; margin: 10px; font-size: 24px; font-weight: bold;
            background: white; color: #333; border: none; border-radius: 50px; cursor: pointer;
            font-family: 'Black Ops One', cursive; text-transform: uppercase;
            transition: 0.2s;
        }
        .btn:hover { transform: scale(1.1); box-shadow: 0 0 20px white; }
        .btn-secondary { background: #333; color: white; }

        /* Поле ссылки */
        .link-box { 
            background: rgba(0,0,0,0.6); padding: 15px; border-radius: 10px; 
            font-family: monospace; font-size: 18px; color: #4cd137; border: 2px solid #4cd137;
            margin-top: 20px; user-select: all; cursor: pointer;
        }

        /* Выбор скина */
        .skin-selector { display: flex; gap: 10px; margin-bottom: 30px; }
        .skin-option { width: 50px; height: 50px; border-radius: 50%; border: 3px solid white; cursor: pointer; transition: transform 0.2s; }
        .skin-option.selected { box-shadow: 0 0 15px #fff; border-color: yellow; transform: scale(1.3); }

        /* ИГРА */
        #game-container { position: relative; width: 100vw; height: 100vh; display: none; justify-content: center; align-items: center; }
        canvas { border: 4px solid #444; box-shadow: 0 0 50px rgba(0,0,0,0.8); background: radial-gradient(circle, #333 0%, #111 100%); border-radius: 8px; }
        #hud { position: absolute; top: 20px; width: 800px; display: flex; justify-content: space-between; font-family: 'Black Ops One', cursive; pointer-events: none; z-index: 5; }
        .score-box { font-size: 60px; text-shadow: 4px 4px 0 #000; }
    </style>
</head>
<body>

    <div id="menu-screen" class="screen">
        <h1>TREMOR BALL</h1>
        <p>ВЫБЕРИ ЦВЕТ:</p>
        <div class="skin-selector">
            <div class="skin-option selected" style="background: #3498db" onclick="selectSkin('#3498db', this)"></div>
            <div class="skin-option" style="background: #e74c3c" onclick="selectSkin('#e74c3c', this)"></div>
            <div class="skin-option" style="background: #2ecc71" onclick="selectSkin('#2ecc71', this)"></div>
            <div class="skin-option" style="background: #f1c40f" onclick="selectSkin('#f1c40f', this)"></div>
        </div>
        <button class="btn" onclick="findGame('random')">СЛУЧАЙНЫЙ ИГРОК</button>
        <button class="btn btn-secondary" onclick="findGame('private')">ИГРАТЬ С ДРУГОМ</button>
    </div>

    <div id="wait-screen" class="screen hidden">
        <h1>ОЖИДАНИЕ...</h1>
        <div id="invite-section" class="hidden" style="text-align: center;">
            <p>Отправь эту ссылку другу:</p>
            <div id="invite-link" class="link-box" onclick="copyLink()">Генерация ссылки...</div>
            <p style="font-size: 12px; color: #aaa; margin-top: 5px;">(Нажми на ссылку, чтобы скопировать)</p>
        </div>
        <button class="btn btn-secondary" onclick="location.reload()" style="margin-top: 30px;">НАЗАД</button>
    </div>

    <div id="game-container">
        <div id="hud">
            <div style="color: #3498db" class="score-box" id="scoreLeft">0</div>
            <div style="color: #e74c3c" class="score-box" id="scoreRight">0</div>
        </div>
    </div>

<script>
    const socket = io();
    let mySkin = '#3498db';
    let myId = null;
    let mySide = null;
    let playersMap = {}; 
    let ball;
    let engine, render, runner;
    
    // Переменные для физики
    let jumpCount = 0;
    const MAX_JUMPS = 2;
    let lastKeyPress = { key: '', time: 0 };
    let shakeDuration = 0;

    // --- ЛОГИКА МЕНЮ ---

    // 1. Выбор скина
    function selectSkin(color, el) {
        mySkin = color;
        document.querySelectorAll('.skin-option').forEach(d => d.classList.remove('selected'));
        el.classList.add('selected');
    }

    // 2. Проверка ссылки при входе
    const urlParams = new URLSearchParams(window.location.search);
    const roomFromUrl = urlParams.get('room');

    if (roomFromUrl) {
        document.getElementById('menu-screen').innerHTML = "<h1>ПОДКЛЮЧЕНИЕ...</h1>";
        setTimeout(() => {
            socket.emit('findMatch', { mode: 'private', roomId: roomFromUrl, skin: mySkin });
        }, 500);
    }

    // 3. Кнопки поиска
    function findGame(mode) {
        document.getElementById('menu-screen').classList.add('hidden');
        document.getElementById('wait-screen').classList.remove('hidden');
        
        socket.emit('findMatch', { mode: mode, skin: mySkin });
    }

    // 4. Ожидание
    socket.on('waiting', (data) => {
        if (data.roomId) {
            // Показываем ссылку для друга
            document.getElementById('invite-section').classList.remove('hidden');
            const link = `${window.location.origin}/?room=${data.roomId}`;
            document.getElementById('invite-link').innerText = link;
        } else {
            // Просто ждем (случайный поиск)
            document.querySelector('#wait-screen h1').innerText = "ПОИСК ИГРОКА...";
        }
    });

    function copyLink() {
        const text = document.getElementById('invite-link').innerText;
        navigator.clipboard.writeText(text).then(() => alert("Ссылка скопирована!"));
    }

    // --- ЛОГИКА ИГРЫ (START) ---

    socket.on('gameStart', (data) => {
        // Скрываем меню, показываем игру
        document.querySelectorAll('.screen').forEach(el => el.classList.add('hidden'));
        document.getElementById('game-container').style.display = 'flex';

        myId = socket.id;
        mySide = data.self.side;
        
        initGame();
        
        // Спавн игроков
        createPlayer(myId, data.self.x, data.self.y, data.self.skin, true);
        data.opponents.forEach(p => createPlayer(p.id, p.x, p.y, p.skin, false));
    });

    socket.on('playerJoined', p => createPlayer(p.id, p.x, p.y, p.skin, false));
    
    socket.on('playerLeft', id => { 
        if(playersMap[id]) { 
            Matter.Composite.remove(engine.world, playersMap[id]); 
            delete playersMap[id]; 
        } 
    });

    socket.on('updatePlayer', (data) => {
        if (playersMap[data.id]) {
            Matter.Body.setPosition(playersMap[data.id], { 
                x: playersMap[data.id].position.x + (data.x - playersMap[data.id].position.x) * 0.5, 
                y: playersMap[data.id].position.y + (data.y - playersMap[data.id].position.y) * 0.5 
            });
        }
    });

    socket.on('updateBall', (data) => {
        if (playersMap[myId] && calculateDistance(playersMap[myId].position, ball.position) > 150) {
             Matter.Body.setPosition(ball, { x: data.x, y: data.y });
             Matter.Body.setVelocity(ball, { x: data.vx, y: data.vy });
        }
    });

    socket.on('scoreUpdate', s => { 
        document.getElementById('scoreLeft').innerText = s.left; 
        document.getElementById('scoreRight').innerText = s.right; 
    });

    socket.on('resetRound', pos => { 
        Matter.Body.setPosition(ball, pos); 
        Matter.Body.setVelocity(ball, { x: 0, y: 0 }); 
        Matter.Body.setAngularVelocity(ball, 0); 
    });

    // --- ФИЗИКА (MATTER.JS) ---

    function initGame() {
        const { Engine, Render, Runner, Bodies, Composite, Body, Events } = Matter;
        
        engine = Engine.create();
        engine.world.gravity.y = 1.4;

        render = Render.create({
            element: document.getElementById('game-container'),
            engine: engine,
            options: { width: 800, height: 600, wireframes: false, background: 'transparent' }
        });

        const ground = Bodies.rectangle(400, 610, 810, 60, { isStatic: true, render: { fillStyle: '#555' }, label: 'ground' });
        const leftWall = Bodies.rectangle(-10, 300, 20, 600, { isStatic: true, label: 'wall' });
        const rightWall = Bodies.rectangle(810, 300, 20, 600, { isStatic: true, label: 'wall' });
        const net = Bodies.rectangle(400, 520, 10, 180, { isStatic: true, render: { fillStyle: '#fff' }, chamfer: { radius: 5 } });
        
        ball = Bodies.circle(400, 150, 20, { 
            restitution: 0.9, friction: 0.005, frictionAir: 0.015, density: 0.05,
            render: { fillStyle: '#f1c40f' }
        });

        Composite.add(engine.world, [ground, leftWall, rightWall, net, ball]);

        // Управление
        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            // Рывок
            const now = Date.now();
            if (lastKeyPress.key === e.code && now - lastKeyPress.time < 300 && playersMap[myId]) {
                const force = 0.2;
                if (e.code === 'ArrowLeft' || e.code === 'KeyA') Body.applyForce(playersMap[myId], playersMap[myId].position, { x: -force, y: 0 });
                if (e.code === 'ArrowRight' || e.code === 'KeyD') Body.applyForce(playersMap[myId], playersMap[myId].position, { x: force, y: 0 });
                lastKeyPress.key = '';
            } else {
                lastKeyPress = { key: e.code, time: now };
            }
            // Прыжок
            if ((e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'Space') && playersMap[myId]) {
                if (jumpCount < MAX_JUMPS) {
                    Body.setVelocity(playersMap[myId], { x: playersMap[myId].velocity.x, y: -16 });
                    jumpCount++;
                }
            }
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        // Сброс прыжков
        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                if (playersMap[myId] && (pair.bodyA === playersMap[myId] || pair.bodyB === playersMap[myId])) {
                    const other = pair.bodyA === playersMap[myId] ? pair.bodyB : pair.bodyA;
                    if (other.label === 'ground') jumpCount = 0;
                }
            });
        });

        // Loop
        Events.on(engine, 'afterUpdate', () => {
            if (!playersMap[myId]) return;
            const me = playersMap[myId];
            const speed = 7;

            if (keys['ArrowLeft'] || keys['KeyA']) Body.setVelocity(me, { x: -speed, y: me.velocity.y });
            else if (keys['ArrowRight'] || keys['KeyD']) Body.setVelocity(me, { x: speed, y: me.velocity.y });
            else Body.setVelocity(me, { x: me.velocity.x * 0.9, y: me.velocity.y });
            
            Body.setAngle(me, 0);

            socket.emit('move', { x: me.position.x, y: me.position.y, vx: me.velocity.x, vy: me.velocity.y });

            if (calculateDistance(me.position, ball.position) < 150) {
                socket.emit('syncBall', { x: ball.position.x, y: ball.position.y, vx: ball.velocity.x, vy: ball.velocity.y });
            }

            if (mySide === 'left' && ball.position.y > 580) {
                triggerShake();
                socket.emit('goal', ball.position.x < 400 ? 'right' : 'left');
            }
        });

        // Тряска
        Events.on(render, 'beforeRender', () => {
             if (shakeDuration > 0) {
                const dx = (Math.random() - 0.5) * 15;
                const dy = (Math.random() - 0.5) * 15;
                render.canvas.style.transform = `translate(${dx}px, ${dy}px)`;
                shakeDuration--;
            } else {
                render.canvas.style.transform = 'none';
            }
        });

        Render.run(render);
        Runner.run(Runner.create(), engine);
    }

    function createPlayer(id, x, y, color, isMe) {
        if(playersMap[id]) return;
        const p = Matter.Bodies.circle(x, y, 30, { 
            friction: 0, frictionAir: 0.05, restitution: 0, 
            render: { fillStyle: color || '#999', strokeStyle: '#fff', lineWidth: isMe ? 3 : 0 },
            label: isMe ? 'me' : 'enemy'
        });
        playersMap[id] = p; 
        Matter.Composite.add(engine.world, p);
    }

    function triggerShake() { shakeDuration = 20; }
    function calculateDistance(v1, v2) { return Math.sqrt(Math.pow(v1.x - v2.x, 2) + Math.pow(v1.y - v2.y, 2)); }
</script>
</body>
</html>