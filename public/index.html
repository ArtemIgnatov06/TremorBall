<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>TremorBall Online</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        body { margin: 0; background: #1a1a1a; color: white; font-family: 'Arial', sans-serif; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        canvas { border: 4px solid #444; box-shadow: 0 0 30px rgba(0,0,0,0.5); background: #333; }
        #ui { position: absolute; top: 20px; width: 800px; display: flex; justify-content: space-between; font-size: 24px; font-weight: bold; pointer-events: none; }
        .score { font-size: 48px; text-shadow: 2px 2px 0 #000; }
        #status { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 32px; background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; display: none; }
    </style>
</head>
<body>

<div id="ui">
    <div style="color: #3498db">ИГРОК 1: <span id="scoreLeft" class="score">0</span></div>
    <div style="color: #e74c3c">ИГРОК 2: <span id="scoreRight" class="score">0</span></div>
</div>
<div id="status">Ожидание игрока...</div>

<script>
    const socket = io();
    
    // --- НАСТРОЙКИ MATTER.JS ---
    const { Engine, Render, Runner, Bodies, Composite, Body, Vector, Events } = Matter;
    
    const engine = Engine.create();
    engine.world.gravity.y = 1.2; // Чуть тяжелее гравитация для динамики
    
    const render = Render.create({
        element: document.body,
        engine: engine,
        options: {
            width: 800,
            height: 600,
            wireframes: false,
            background: 'transparent' // Чтобы видеть наш CSS фон
        }
    });

    // --- ОБЪЕКТЫ ---
    // Стены (чтобы мяч не улетал)
    const ground = Bodies.rectangle(400, 610, 810, 60, { isStatic: true, render: { fillStyle: '#555' }, label: 'ground' });
    const leftWall = Bodies.rectangle(-10, 300, 20, 600, { isStatic: true });
    const rightWall = Bodies.rectangle(810, 300, 20, 600, { isStatic: true });
    const ceiling = Bodies.rectangle(400, -500, 810, 100, { isStatic: true }); // Высокий потолок
    
    // Сетка
    const net = Bodies.rectangle(400, 520, 10, 180, { 
        isStatic: true, 
        render: { fillStyle: '#fff' },
        chamfer: { radius: 5 } // Закругленные края
    });

    // Мяч
    let ball = Bodies.circle(400, 100, 20, { 
        restitution: 0.95, // Прыгучесть
        friction: 0.005,
        frictionAir: 0.02,
        render: { fillStyle: '#f1c40f' },
        label: 'ball'
    });

    // Игроки (создаются пустыми, обновляются сервером)
    let myId = null;
    let mySide = null;
    let playersMap = {}; // Хранит тела Matter.js
    
    Composite.add(engine.world, [ground, leftWall, rightWall, ceiling, net, ball]);

    // --- УПРАВЛЕНИЕ ---
    const keys = {};
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);

    // --- ТРЯСКА ЭКРАНА (TREMOR EFFECT) ---
    let shakeDuration = 0;
    function triggerShake() {
        shakeDuration = 15; // Кадров тряски
    }

    Events.on(render, 'beforeRender', function() {
        if (shakeDuration > 0) {
            const dx = (Math.random() - 0.5) * 10;
            const dy = (Math.random() - 0.5) * 10;
            render.canvas.style.transform = `translate(${dx}px, ${dy}px)`;
            shakeDuration--;
        } else {
            render.canvas.style.transform = 'none';
        }
    });

    // --- СЕТЕВАЯ ЛОГИКА ---
    
    socket.on('init', (data) => {
        myId = socket.id;
        mySide = data.self.side;
        updateScore(data.score);
        document.getElementById('status').style.display = 'none';

        // Создаем своего игрока
        createPlayer(myId, data.self.x, data.self.y, true);

        // Создаем соперника, если он уже есть
        for (let id in data.players) {
            if (id !== myId) {
                createPlayer(id, data.players[id].x, data.players[id].y, false);
            }
        }
    });

    socket.on('playerJoined', (p) => {
        createPlayer(p.id, p.x, p.y, false);
    });

    socket.on('playerLeft', (id) => {
        if (playersMap[id]) {
            Composite.remove(engine.world, playersMap[id]);
            delete playersMap[id];
        }
    });

    socket.on('updatePlayer', (data) => {
        if (playersMap[data.id]) {
            // Плавная интерполяция для врага
            Body.setPosition(playersMap[data.id], { x: data.x, y: data.y });
        }
    });

    socket.on('updateBall', (data) => {
        // Синхронизируем мяч, если мы НЕ контролируем его
        // (Простая логика: кто ближе к мячу, тот и "сервер" мяча, но тут для надежности просто принимаем)
        if (calculateDistance(playersMap[myId].position, ball.position) > 150) {
             Body.setPosition(ball, { x: data.x, y: data.y });
             Body.setVelocity(ball, { x: data.vx, y: data.vy });
        }
    });

    socket.on('scoreUpdate', (score) => updateScore(score));
    
    socket.on('resetRound', (pos) => {
        Body.setPosition(ball, pos);
        Body.setVelocity(ball, { x: 0, y: 0 });
        Body.setAngularVelocity(ball, 0);
    });

    function createPlayer(id, x, y, isMe) {
        const color = (id === myId) ? (mySide === 'left' ? '#3498db' : '#e74c3c') : '#999';
        
        const playerBody = Bodies.circle(x, y, 30, { 
            friction: 0.1, 
            restitution: 0,
            render: { fillStyle: color },
            label: isMe ? 'me' : 'enemy'
        });
        
        playersMap[id] = playerBody;
        Composite.add(engine.world, playerBody);
    }

    function updateScore(s) {
        document.getElementById('scoreLeft').innerText = s.left;
        document.getElementById('scoreRight').innerText = s.right;
    }

    function calculateDistance(v1, v2) {
        return Math.sqrt(Math.pow(v1.x - v2.x, 2) + Math.pow(v1.y - v2.y, 2));
    }

    // --- ИГРОВОЙ ЦИКЛ ---
    Events.on(engine, 'afterUpdate', () => {
        if (!myId || !playersMap[myId]) return;

        const me = playersMap[myId];
        const speed = 6;
        const jump = -18;

        // Движение
        if (keys['ArrowLeft'] || keys['KeyA']) Body.setVelocity(me, { x: -speed, y: me.velocity.y });
        else if (keys['ArrowRight'] || keys['KeyD']) Body.setVelocity(me, { x: speed, y: me.velocity.y });
        else Body.setVelocity(me, { x: 0, y: me.velocity.y });

        // Прыжок (только если на земле, проверяем примерно по Y)
        if ((keys['ArrowUp'] || keys['KeyW'] || keys['Space']) && me.position.y > 560) {
            Body.setVelocity(me, { x: me.velocity.x, y: jump });
        }
        
        // Ограничение вращения игрока
        Body.setAngle(me, 0);

        // Отправка позиции
        socket.emit('move', { x: me.position.x, y: me.position.y });

        // ЛОГИКА ГОЛА (Только я проверяю, если я хост раунда - упрощенно)
        // Если мяч коснулся пола
        if (ball.position.y > 580) {
            // Эффект удара
            triggerShake();
            
            // Если я левый игрок, я отвечаю за отправку гола, чтобы не дублировать
            if (mySide === 'left') {
                if (ball.position.x < 400) socket.emit('goal', 'right');
                else socket.emit('goal', 'left');
            }
        }

        // Если я ближе всех к мячу, я отправляю его физику остальным
        if (calculateDistance(me.position, ball.position) < 150) {
            socket.emit('syncBall', { 
                x: ball.position.x, y: ball.position.y, 
                vx: ball.velocity.x, vy: ball.velocity.y 
            });
        }
    });

    Render.run(render);
    Runner.run(Runner.create(), engine);

</script>
</body>
</html>